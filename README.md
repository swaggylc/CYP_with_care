#### 技术栈

`Vue3+Vite+Ts+Vue-router+Pinia+Element-plus+Axios+Echarts`

1. #### 企业级别编码规范

2. #### 从零到一，封装一个完整的后台管理系统

3. #### 菜单权限与按钮权限

4. #### 数据可视化大屏

5. #### svg矢量图在项目中的应用

6. #### 主题颜色切换与暗黑模式切换

#### trouble

1. ##### 递归组件生成动态菜单

    判断一级路由的情况，无子路由、有且只有一个子路由、有两个及以上子路由

    前两种均遍历 <el-menu-item> 即可，最后一种情况

    使用 <el-sub-menu> ，在子菜单处递归调用Menu组件

    注意：递归组件必须有name，无论什么情况，<el-menu-item> 还是 <el-sub-menu> 都必须有唯一值index

2. ##### el-menu右侧的白色边框隐藏

    .el-menu{

    ​		border:none

    }

3. ##### 全屏模式的切换

    可利用插件，也可利用原生的DOM方法，`document.documentElement.*requestFullscreen*() `与 `document.*exitFullscreen*()`

4. ##### 利用请求头携带token获取用户信息

    可在axios的请求拦截器中设置请求头携带公共参数如token

    ```js
    // 第二步：配置请求拦截器
    request.interceptors.request.use((config) => {
      // config配置对象，headers属性，存放请求头信息，经常给服务器携带公共参数，如token
      // 返回config配置对象
      // 从本地存储中获取token
      let token = GET_SOME('TOKEN')
      // 判断token是否存在
      if (token) {
        // 给请求头添加token
        config.headers.token = token
      }
      return config
    })
    ```

5. ##### 设置进度条

    安装：`npm i nprogress`	引入：

    ```
    // *引入进度条插件*
    
    //*@ts-ignore*
    
    *import* NProgress *from* '*nprogress*'
    
    // *引入进度条样式*
    
    *import* '*nprogress/nprogress.css*'
    ```

    配置进度条：`NProgress.*configure*({ *showSpinner*: *false* })`	去除小圆圈

    设置开始与结束： `NProgress.*start*()`	 `NProgress.*done*()`

6. ##### 路由鉴权

    通过token判断用户是否登陆，有token所有路由放行，但访问login组件会被重定向到首页

    ​	若用户已登录，但无用户信息，如username等，则通知用户仓库发送请求获取用户信息，成功后放行

    ​	若用户已登陆，但无用户信息，且获取信息失败，即token失效，跳转至login组件，重新获取token

    若未登录，则跳转到login组件，携带query参数，保留当前路由路径，登陆后可直接跳转至退出登陆时的路径

7. ##### 表单输入框自动聚焦

    点击添加属性值按钮时及div切换为input框时，让input框能够自动聚焦

    el-input实例上有focus方法，在div切换为input框时，调用该方法即可让该input实例自动聚焦

    1. 思路一：通过某一变量控制focus方法是否调用，如：该变量为真时，调用focus方法，但问题在于input框可能有多个，若使用这种方法，则会导致一个变量控制多个input框，显然不合理。
    2. 思路二：通过ref的函数写法，获取到input实例，当由div切换至input时，将获取到的input实例通过下标传入一数组中，当input失去焦点时（切换为div），这一数组的该下标的元素为null。注意：当由div切换至input时，模板会重新渲染，会重新解析DOM，而我们必须保证在DOM解析完成后才能获取到这个input实例，若DOM解析未完成，则无法获取该input实例；则考虑到nextTick函数，在它的回调中将该input实例传入数组中，即可保证存在该input实例。同理，点击添加属性值按钮时，让存储input实例的数组的最后一项调用focus方法，同样也需要在DOM解析完成后调用该方法。
    
8. ##### 表单数据回显的深浅拷贝

    当我们获取到数据将表单数据进行回显时（通常用于修改业务），若回显的数据结构为对象中还有对象，如对象中又包含对象，或对象中包含数组等，我们必须将该数据进行深拷贝后再通过Object.*assign*（）方法合并，因为Object.*assign*（）方法是浅拷贝，合并后目标对象中的复杂数据（对象，数组等）的指针依然指向源对象的该属性，由此以来，我们若对目标对象的该复杂数据类型属性进行操作，则会影响到源对象的该属性，所以我们在合并前必须进行深拷贝。
    
9. ##### 在spu管理模块中，父组件有部分数据，而子组件需要全部数据，请求应该何时何地发送？

    1. 思路一：在父组件中发送请求获取数据再传值给子组件，能达到效果但不优雅，若请求较多时可能要传多组数据
    2. 思路二：在子组件挂载时，在子组件中发送请求，在本项目中不适用。由于子组件使用v-show来展示与隐藏，组件的挂载时机要早于展示时机，若是在挂载时发送请求，某些请求拿不到参数，从而失败。若使用v-if或许能解决该问题，但v-if较为耗费性能，不能完美解决该问题。
    3. 思路三：在子组件中添加一组件实例方法并对外暴露，在该方法中发送请求，在父组件中获取子组件实例，在适当时机调用该方法，即可发送请求，且返回的数据在子组件中，在该方法中可以将父组件的部分数据以参数形式传给子组件，一举两得，是个较好的解决办法。

10. ##### 根据所有的销售属性和已选择的销售属性找出未选择的销售属性

    使用两次迭代方法，如filter，forEach，some，every等。第一次迭代使用所有销售属性数组的fliter或forEach方法，在它的回调中使用已选择的销售属性数组的some或every方法，判断对象的name属性是否相等，返回ture或false，则能够根据返回值判断这个所有销售属性数组中的此次迭代对象是否在已选择销售属性数组中，若不在则将其推入一个新的空数组中。若在计算属性的回调中，则将这个数组作为返回值返回即可。
    
11. **菜单与按钮权限**

     超级管理员账号：拥有所有的菜单和按钮权限

     其他账号：包含不同的菜单及按钮权限

     即：不同账号能够访问的菜单栏和按钮是不一样的

     整个项目目前拥有多少个路由：

     - login（登陆页面）
     - 404
     - 任意路由（输入不存在的路径重定向到404）
     - 首页（/home）
     - 数据大屏
     - 权限管理（三个子路由，路径重定向到第一个子路由）
     - 商品模块管理（四个子路由，路径重定向到第一个子路由）

     **开发菜单权限：**

     第一步：拆分路由

     - 静态路由（常量路由）：无论什么账号都拥有的路由

         login、首页、数据大屏、404

     - 异步路由：根据不同身份而指定的路由

         权限管理（三个子路由）、商品模块管理（四个子路由）

     - 任意路由：任意路由

     思路：在目前的项目中，由于将所有路由都放在常量路由数组中进行的注册，故所有账号都能够拥有全部的菜单权限

     解决方法：根据登陆时返回的用户信息中的routes（Array）字段，来判断其拥有的菜单权限（按钮同理，buttons字段），若routes为空数组，则只注册常量路由，根据其中的信息再注册异步路由。
    
    在仓库的获取用户信息方法中计算当前用户需要展示的异步路由（通过*filterAsyncRoutes*方法），在调用该方法时，传如的asyncRoutes数组需要是深拷贝后的，由于在该方法中对子路由进行了重新赋值，若不进行深拷贝，则会对下一个账号有影响；菜单列表即为常量路由+计算后的异步路由+任意路由；再将计算后的异步路由和任意路由动态追加到路由表中；若在异步路由访问的组件处刷新，可能会导致白屏的问题。原因：*若此处访问的是异步路由，则可能导致虽然已经获取到了用户信息，但是异步路由还未添加到路由表中*，解决方法：*next*({ *...*to })
    
    **使用next（）为何会导致白屏：**
    
    使用`next()`而不是`next({...to})`会导致白屏的问题，因为在异步组件加载的情况下，直接调用`next()`会中断路由导航的流程，导致页面无法正确渲染。
    
    当你在异步路由组件加载过程中调用`next()`时，发生了以下情况：
    
    1. 异步组件加载尚未完成，路由表中可能还没有加载完的路由记录。
    2. 调用`next()`会中断当前导航，不会继续前进到目标路由。
    3. 页面因为中断了导航流程，无法渲染异步组件的内容，导致白屏问题。
    
    实际上，`next()`的调用会被视为当前导航完成，即使异步组件尚未加载完成。这意味着路由表不会得到更新，也不会重新触发路由导航，因此无法解决异步组件加载完成后渲染的问题，从而导致页面白屏。
    
    为了解决这个问题，你需要使用`next({...to})`，将目标路由的信息传递给`next`方法，以便在异步组件加载完成后，路由系统能够重新触发导航并正确渲染目标组件。这种做法会让路由系统知道用户的意图是前往目标路由，即使目标路由的组件尚未加载完成。
    
    **按钮权限的实现：**
    
    在用户仓库中收集用户的按钮权限数组，即可在组件的按钮上添加`v-if=‘userStore.buttons.includes（btn.User.add）’`，若不包含则隐藏按钮，但不便的是在每一个组件内都要引入用户仓库，略有繁琐，自定义指令可能更加便捷。
    
    自定义指令：
    
    ```js
    export const isHasButton = (app: any) => {
      // 全局自定义指令：判断当前用户是否有按钮权限
      app.directive('has', {
        // 代表使用当前指令的元素（DOM,组件）挂载完毕后执行一次
        mounted(el: any, options: any) {
          // console.log(userStore.buttons)
          // 自定义指令右侧的值是否包含在仓库中的按钮权限中，如果不包含，就删除当前元素
          if (!userStore.buttons.includes(options.value)) {
            el.parentNode.removeChild(el)
          }
        },
      })
    }
    
    // z
    <el-button type="primary" @click="addUser" v-has="`btn.User.add`">添加</el-button>
    ```
    
12. 

